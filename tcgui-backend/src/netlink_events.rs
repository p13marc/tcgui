//! Netlink event listener for real-time interface change notifications.
//!
//! This module provides event-driven interface monitoring using Linux netlink
//! multicast groups instead of polling. It listens for RTMGRP_LINK events
//! to detect interface additions, removals, and state changes in real-time.

use futures_util::stream::StreamExt;
use rtnetlink::packet_core::NetlinkPayload;
use rtnetlink::packet_route::RouteNetlinkMessage;
use rtnetlink::packet_route::link::LinkMessage;
use rtnetlink::sys::{AsyncSocket, SocketAddr};
use rtnetlink::{constants::RTMGRP_LINK, new_connection};
use tokio::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Events generated by the netlink listener
///
/// The inner `LinkInfo` is used for Debug output to aid troubleshooting.
#[derive(Debug, Clone)]
/// Fields used via Debug trait for logging netlink events
#[allow(dead_code)]
pub enum NetlinkEvent {
    /// A new link was added
    Added(LinkInfo),
    /// A link was removed
    Removed(LinkInfo),
    /// A link state changed (up/down)
    StateChanged(LinkInfo),
}

/// Basic information about a link from netlink messages
#[derive(Debug, Clone)]
pub struct LinkInfo {
    /// Interface index
    pub index: u32,
    /// Interface name (if available)
    pub name: Option<String>,
}

impl LinkInfo {
    fn from_link_message(msg: &LinkMessage) -> Self {
        use rtnetlink::packet_route::link::LinkAttribute;

        let mut name = None;
        for attr in &msg.attributes {
            if let LinkAttribute::IfName(n) = attr {
                name = Some(n.clone());
                break;
            }
        }

        Self {
            index: msg.header.index,
            name,
        }
    }
}

/// Netlink event listener that monitors link changes in real-time
pub struct NetlinkEventListener {
    /// Channel sender for netlink events
    event_tx: mpsc::Sender<NetlinkEvent>,
}

impl NetlinkEventListener {
    /// Creates a new netlink event listener and returns the event receiver
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    pub fn new(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (Self { event_tx }, event_rx)
    }

    /// Starts listening for netlink events
    ///
    /// This spawns a background task that listens for link change events
    /// and sends them through the channel.
    ///
    /// # Returns
    ///
    /// Ok(()) if the listener started successfully, Err on failure
    pub async fn start(self) -> Result<(), String> {
        // Create a new netlink connection
        let (mut connection, _handle, mut messages) =
            new_connection().map_err(|e| format!("Failed to create netlink connection: {}", e))?;

        // Bind to RTMGRP_LINK multicast group to receive link events
        let addr = SocketAddr::new(0, RTMGRP_LINK);
        connection
            .socket_mut()
            .socket_mut()
            .bind(&addr)
            .map_err(|e| format!("Failed to bind netlink socket: {}", e))?;

        info!("Netlink event listener started, monitoring link changes");

        // Spawn the connection handler
        tokio::spawn(connection);

        // Spawn the message processing task
        let event_tx = self.event_tx;
        tokio::spawn(async move {
            while let Some((message, _)) = messages.next().await {
                match message.payload {
                    NetlinkPayload::InnerMessage(RouteNetlinkMessage::NewLink(link_msg)) => {
                        let info = LinkInfo::from_link_message(&link_msg);
                        debug!(
                            "Netlink: NewLink event for {} (index {})",
                            info.name.as_deref().unwrap_or("unknown"),
                            info.index
                        );
                        if event_tx.send(NetlinkEvent::Added(info)).await.is_err() {
                            warn!("Netlink event receiver dropped, stopping listener");
                            break;
                        }
                    }
                    NetlinkPayload::InnerMessage(RouteNetlinkMessage::DelLink(link_msg)) => {
                        let info = LinkInfo::from_link_message(&link_msg);
                        debug!(
                            "Netlink: DelLink event for {} (index {})",
                            info.name.as_deref().unwrap_or("unknown"),
                            info.index
                        );
                        if event_tx.send(NetlinkEvent::Removed(info)).await.is_err() {
                            warn!("Netlink event receiver dropped, stopping listener");
                            break;
                        }
                    }
                    NetlinkPayload::InnerMessage(RouteNetlinkMessage::SetLink(link_msg)) => {
                        let info = LinkInfo::from_link_message(&link_msg);
                        debug!(
                            "Netlink: SetLink event for {} (index {})",
                            info.name.as_deref().unwrap_or("unknown"),
                            info.index
                        );
                        if event_tx
                            .send(NetlinkEvent::StateChanged(info))
                            .await
                            .is_err()
                        {
                            warn!("Netlink event receiver dropped, stopping listener");
                            break;
                        }
                    }
                    _ => {
                        // Ignore other message types
                    }
                }
            }
            error!("Netlink message stream ended unexpectedly");
        });

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_link_info_creation() {
        let info = LinkInfo {
            index: 1,
            name: Some("eth0".to_string()),
        };
        assert_eq!(info.index, 1);
        assert_eq!(info.name, Some("eth0".to_string()));
    }

    #[test]
    fn test_netlink_event_listener_creation() {
        let (listener, _rx) = NetlinkEventListener::new(100);
        // Just verify it can be created
        drop(listener);
    }
}
