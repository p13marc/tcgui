//! Netlink event listener for real-time interface and TC change notifications.
//!
//! This module provides event-driven monitoring using nlink's Connection API.
//! It listens for link and TC events to detect interface additions, removals,
//! state changes, and qdisc changes in real-time.
//!
//! # Multi-Namespace Support
//!
//! The module supports monitoring events across multiple network namespaces:
//! - Default namespace: Always monitored
//! - Named namespaces: Created via `ip netns add`
//! - Container namespaces: Accessed via `/proc/<pid>/ns/net`
//!
//! Use `NamespaceEventManager` to manage event streams for multiple namespaces.

use futures_util::StreamExt;
use nlink::RtnetlinkGroup;
use nlink::netlink::events::NetworkEvent;
use nlink::netlink::messages::{LinkMessage, TcMessage};
use nlink::netlink::{Connection, Route};
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Events generated by the netlink listener
#[derive(Debug, Clone)]
pub enum NetlinkEvent {
    /// A new link was added (also used for state changes since netlink sends NewLink for both)
    LinkAdded(LinkInfo),
    /// A link was removed
    LinkRemoved(LinkInfo),
    /// A new qdisc was added or changed
    QdiscAdded(TcInfo),
    /// A qdisc was removed
    QdiscRemoved(TcInfo),
}

/// Basic information about a link from netlink messages
#[derive(Debug, Clone)]
pub struct LinkInfo {
    /// Interface index
    pub index: u32,
    /// Interface name (if available)
    pub name: Option<String>,
    /// Whether the interface is up
    pub is_up: Option<bool>,
}

impl LinkInfo {
    fn from_link_message(msg: &LinkMessage) -> Self {
        Self {
            index: msg.ifindex(),
            name: msg.name().map(|s| s.to_string()),
            is_up: Some(msg.is_up()),
        }
    }
}

/// Basic information about a TC qdisc from netlink messages
#[derive(Debug, Clone)]
pub struct TcInfo {
    /// Interface index
    pub ifindex: u32,
    /// Qdisc handle
    pub handle: u32,
    /// Qdisc parent handle (useful for identifying qdisc hierarchy)
    #[allow(dead_code)]
    pub parent: u32,
    /// Qdisc kind (e.g., "netem", "htb", "fq_codel")
    pub kind: Option<String>,
}

impl TcInfo {
    fn from_tc_message(msg: &TcMessage) -> Self {
        Self {
            ifindex: msg.ifindex(),
            handle: msg.handle(),
            parent: msg.parent(),
            kind: msg.kind().map(|s| s.to_string()),
        }
    }

    /// Check if this is a netem qdisc
    pub fn is_netem(&self) -> bool {
        self.kind.as_deref() == Some("netem")
    }
}

/// Netlink event listener that monitors link and TC changes in real-time
pub struct NetlinkEventListener {
    /// Channel sender for netlink events
    event_tx: mpsc::Sender<NetlinkEvent>,
    /// Whether to subscribe to TC events
    subscribe_tc: bool,
}

impl NetlinkEventListener {
    /// Creates a new netlink event listener and returns the event receiver
    ///
    /// # Arguments
    ///
    /// * `buffer_size` - Size of the event channel buffer
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    #[allow(dead_code)]
    pub fn new(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (
            Self {
                event_tx,
                subscribe_tc: false,
            },
            event_rx,
        )
    }

    /// Creates a new netlink event listener with TC event subscription
    ///
    /// # Arguments
    ///
    /// * `buffer_size` - Size of the event channel buffer
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    pub fn new_with_tc(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (
            Self {
                event_tx,
                subscribe_tc: true,
            },
            event_rx,
        )
    }

    /// Starts listening for netlink events
    ///
    /// This spawns a background task that listens for link and optionally TC
    /// change events and sends them through the channel.
    ///
    /// # Returns
    ///
    /// Ok(()) if the listener started successfully, Err on failure
    pub async fn start(self) -> Result<(), String> {
        // Create a connection and subscribe to events
        let mut conn = Connection::<Route>::new()
            .map_err(|e| format!("Failed to create connection: {}", e))?;

        // Subscribe to link events, and optionally TC events
        let groups = if self.subscribe_tc {
            vec![RtnetlinkGroup::Link, RtnetlinkGroup::Tc]
        } else {
            vec![RtnetlinkGroup::Link]
        };

        conn.subscribe(&groups)
            .map_err(|e| format!("Failed to subscribe to events: {}", e))?;

        info!(
            "Netlink event listener started (links: true, tc: {})",
            self.subscribe_tc
        );

        // Spawn the message processing task - consume conn with into_events()
        let event_tx = self.event_tx;
        tokio::spawn(async move {
            let mut events = conn.into_events();
            while let Some(result) = events.next().await {
                match result {
                    Ok(event) => {
                        let netlink_events = parse_network_event(event);

                        for evt in netlink_events {
                            if event_tx.send(evt).await.is_err() {
                                warn!("Netlink event receiver dropped, stopping listener");
                                return;
                            }
                        }
                    }
                    Err(e) => {
                        error!("Error receiving netlink event: {}", e);
                        // Continue listening despite errors
                    }
                }
            }
            error!("Netlink message stream ended unexpectedly");
        });

        Ok(())
    }
}

/// Parse a NetworkEvent into one or more NetlinkEvents
fn parse_network_event(event: NetworkEvent) -> Vec<NetlinkEvent> {
    match event {
        NetworkEvent::NewLink(link_msg) => {
            let info = LinkInfo::from_link_message(&link_msg);
            debug!(
                "Netlink: NewLink event for {} (index {}), up: {:?}",
                info.name.as_deref().unwrap_or("unknown"),
                info.index,
                info.is_up
            );
            vec![NetlinkEvent::LinkAdded(info)]
        }
        NetworkEvent::DelLink(link_msg) => {
            let info = LinkInfo::from_link_message(&link_msg);
            debug!(
                "Netlink: DelLink event for {} (index {})",
                info.name.as_deref().unwrap_or("unknown"),
                info.index
            );
            vec![NetlinkEvent::LinkRemoved(info)]
        }
        NetworkEvent::NewQdisc(tc_msg) => {
            let info = TcInfo::from_tc_message(&tc_msg);
            debug!(
                "Netlink: NewQdisc event for ifindex {}, kind: {:?}, handle: {:08x}",
                info.ifindex, info.kind, info.handle
            );
            vec![NetlinkEvent::QdiscAdded(info)]
        }
        NetworkEvent::DelQdisc(tc_msg) => {
            let info = TcInfo::from_tc_message(&tc_msg);
            debug!(
                "Netlink: DelQdisc event for ifindex {}, kind: {:?}, handle: {:08x}",
                info.ifindex, info.kind, info.handle
            );
            vec![NetlinkEvent::QdiscRemoved(info)]
        }
        // Other events we don't care about
        _ => vec![],
    }
}

/// A netlink event with its originating namespace
#[derive(Debug, Clone)]
pub struct NamespacedEvent {
    /// The namespace this event originated from
    pub namespace: String,
    /// The actual netlink event
    pub event: NetlinkEvent,
}

/// Configuration for a namespace to monitor
#[derive(Debug, Clone)]
pub enum NamespaceTarget {
    /// The default network namespace
    #[allow(dead_code)]
    Default,
    /// A named namespace (from /var/run/netns/)
    #[allow(dead_code)]
    Named(String),
    /// A namespace accessed via path (e.g., /proc/<pid>/ns/net for containers)
    Path { name: String, path: PathBuf },
}

impl NamespaceTarget {
    /// Get the display name for this namespace
    pub fn name(&self) -> &str {
        match self {
            NamespaceTarget::Default => "default",
            NamespaceTarget::Named(name) => name,
            NamespaceTarget::Path { name, .. } => name,
        }
    }
}

/// Manages netlink event streams for multiple namespaces
///
/// This struct creates and manages Connection instances for different
/// network namespaces, multiplexing their events onto a single channel.
pub struct NamespaceEventManager {
    /// Channel sender for namespaced events
    event_tx: mpsc::Sender<NamespacedEvent>,
    /// Track which namespaces are being monitored
    active_namespaces: HashMap<String, tokio::task::JoinHandle<()>>,
}

impl NamespaceEventManager {
    /// Create a new namespace event manager
    ///
    /// # Arguments
    ///
    /// * `buffer_size` - Size of the event channel buffer
    ///
    /// # Returns
    ///
    /// A tuple of (NamespaceEventManager, mpsc::Receiver<NamespacedEvent>)
    pub fn new(buffer_size: usize) -> (Self, mpsc::Receiver<NamespacedEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (
            Self {
                event_tx,
                active_namespaces: HashMap::new(),
            },
            event_rx,
        )
    }

    /// Add a namespace to monitor
    ///
    /// Creates a Connection for the specified namespace and starts
    /// listening for events in a background task.
    ///
    /// # Arguments
    ///
    /// * `target` - The namespace to monitor
    ///
    /// # Returns
    ///
    /// Ok(()) if the stream was started successfully, Err on failure
    pub fn add_namespace(&mut self, target: NamespaceTarget) -> Result<(), String> {
        let namespace_name = target.name().to_string();

        // Don't add duplicate namespaces
        if self.active_namespaces.contains_key(&namespace_name) {
            debug!("Namespace {} already being monitored", namespace_name);
            return Ok(());
        }

        // Create connection for this namespace
        let mut conn = match &target {
            NamespaceTarget::Default => Connection::<Route>::new(),
            NamespaceTarget::Named(name) => {
                // Named namespaces are at /var/run/netns/<name>
                let path = PathBuf::from(format!("/var/run/netns/{}", name));
                Connection::<Route>::new_in_namespace_path(&path)
            }
            NamespaceTarget::Path { path, .. } => Connection::<Route>::new_in_namespace_path(path),
        }
        .map_err(|e| format!("Failed to create connection for {}: {}", namespace_name, e))?;

        // Subscribe to link and TC events
        conn.subscribe(&[RtnetlinkGroup::Link, RtnetlinkGroup::Tc])
            .map_err(|e| {
                format!(
                    "Failed to subscribe to events for {}: {}",
                    namespace_name, e
                )
            })?;

        info!(
            "Started event stream for namespace: {} (links: true, tc: true)",
            namespace_name
        );

        // Spawn a task to process events from this namespace
        let event_tx = self.event_tx.clone();
        let ns_name = namespace_name.clone();
        let handle = tokio::spawn(async move {
            Self::process_namespace_events(conn, ns_name, event_tx).await;
        });

        self.active_namespaces.insert(namespace_name, handle);
        Ok(())
    }

    /// Remove a namespace from monitoring
    ///
    /// Stops the background task for the specified namespace.
    #[allow(dead_code)]
    pub fn remove_namespace(&mut self, namespace: &str) {
        if let Some(handle) = self.active_namespaces.remove(namespace) {
            handle.abort();
            info!("Stopped event stream for namespace: {}", namespace);
        }
    }

    /// Check if a namespace is being monitored
    pub fn is_monitoring(&self, namespace: &str) -> bool {
        self.active_namespaces.contains_key(namespace)
    }

    /// Get the list of namespaces being monitored
    pub fn monitored_namespaces(&self) -> Vec<String> {
        self.active_namespaces.keys().cloned().collect()
    }

    /// Process events from a namespace's event stream
    async fn process_namespace_events(
        conn: Connection<Route>,
        namespace: String,
        event_tx: mpsc::Sender<NamespacedEvent>,
    ) {
        let mut events = conn.into_events();
        while let Some(result) = events.next().await {
            match result {
                Ok(event) => {
                    let netlink_events = parse_network_event(event);

                    for evt in netlink_events {
                        let namespaced_event = NamespacedEvent {
                            namespace: namespace.clone(),
                            event: evt,
                        };

                        if event_tx.send(namespaced_event).await.is_err() {
                            warn!(
                                "Namespace event receiver dropped, stopping listener for {}",
                                namespace
                            );
                            return;
                        }
                    }
                }
                Err(e) => {
                    error!("Error receiving event from namespace {}: {}", namespace, e);
                    // Continue listening despite errors
                }
            }
        }
        error!(
            "Netlink event stream ended unexpectedly for namespace: {}",
            namespace
        );
    }
}

impl Drop for NamespaceEventManager {
    fn drop(&mut self) {
        // Abort all background tasks when the manager is dropped
        for (namespace, handle) in self.active_namespaces.drain() {
            handle.abort();
            debug!("Aborted event stream for namespace: {}", namespace);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_link_info_creation() {
        let info = LinkInfo {
            index: 1,
            name: Some("eth0".to_string()),
            is_up: Some(true),
        };
        assert_eq!(info.index, 1);
        assert_eq!(info.name, Some("eth0".to_string()));
        assert_eq!(info.is_up, Some(true));
    }

    #[test]
    fn test_tc_info_creation() {
        let info = TcInfo {
            ifindex: 2u32,
            handle: 0x10000,
            parent: 0xFFFFFFFF,
            kind: Some("netem".to_string()),
        };
        assert_eq!(info.ifindex, 2);
        assert!(info.is_netem());
    }

    #[test]
    fn test_tc_info_not_netem() {
        let info = TcInfo {
            ifindex: 2u32,
            handle: 0x10000,
            parent: 0xFFFFFFFF,
            kind: Some("fq_codel".to_string()),
        };
        assert!(!info.is_netem());
    }

    #[test]
    fn test_netlink_event_listener_creation() {
        let (listener, _rx) = NetlinkEventListener::new(100);
        assert!(!listener.subscribe_tc);
        drop(listener);
    }

    #[test]
    fn test_netlink_event_listener_with_tc() {
        let (listener, _rx) = NetlinkEventListener::new_with_tc(100);
        assert!(listener.subscribe_tc);
        drop(listener);
    }

    #[test]
    fn test_namespace_target_name() {
        assert_eq!(NamespaceTarget::Default.name(), "default");
        assert_eq!(NamespaceTarget::Named("myns".to_string()).name(), "myns");
        assert_eq!(
            NamespaceTarget::Path {
                name: "container:nginx".to_string(),
                path: PathBuf::from("/proc/1234/ns/net")
            }
            .name(),
            "container:nginx"
        );
    }

    #[test]
    fn test_namespaced_event_creation() {
        let event = NamespacedEvent {
            namespace: "container:nginx".to_string(),
            event: NetlinkEvent::LinkAdded(LinkInfo {
                index: 5,
                name: Some("eth0".to_string()),
                is_up: Some(true),
            }),
        };
        assert_eq!(event.namespace, "container:nginx");
        match event.event {
            NetlinkEvent::LinkAdded(info) => {
                assert_eq!(info.index, 5);
                assert_eq!(info.name, Some("eth0".to_string()));
            }
            _ => panic!("Expected LinkAdded event"),
        }
    }

    #[test]
    fn test_namespace_event_manager_creation() {
        let (manager, _rx) = NamespaceEventManager::new(100);
        assert!(manager.monitored_namespaces().is_empty());
    }
}
