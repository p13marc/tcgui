//! Netlink event listener for real-time interface and TC change notifications.
//!
//! This module provides event-driven monitoring using nlink's EventStream API.
//! It listens for link and TC events to detect interface additions, removals,
//! state changes, and qdisc changes in real-time.

use nlink::netlink::events::{EventStream, NetworkEvent};
use nlink::netlink::messages::{LinkMessage, TcMessage};
use tokio::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Events generated by the netlink listener
#[derive(Debug, Clone)]
pub enum NetlinkEvent {
    /// A new link was added (also used for state changes since netlink sends NewLink for both)
    LinkAdded(LinkInfo),
    /// A link was removed
    LinkRemoved(LinkInfo),
    /// A new qdisc was added or changed
    QdiscAdded(TcInfo),
    /// A qdisc was removed
    QdiscRemoved(TcInfo),
}

/// Basic information about a link from netlink messages
#[derive(Debug, Clone)]
pub struct LinkInfo {
    /// Interface index
    pub index: u32,
    /// Interface name (if available)
    pub name: Option<String>,
    /// Whether the interface is up
    pub is_up: Option<bool>,
}

impl LinkInfo {
    fn from_link_message(msg: &LinkMessage) -> Self {
        Self {
            index: msg.ifindex() as u32,
            name: msg.name.clone(),
            is_up: Some(msg.is_up()),
        }
    }
}

/// Basic information about a TC qdisc from netlink messages
#[derive(Debug, Clone)]
pub struct TcInfo {
    /// Interface index
    pub ifindex: i32,
    /// Qdisc handle
    pub handle: u32,
    /// Qdisc parent handle (useful for identifying qdisc hierarchy)
    #[allow(dead_code)]
    pub parent: u32,
    /// Qdisc kind (e.g., "netem", "htb", "fq_codel")
    pub kind: Option<String>,
}

impl TcInfo {
    fn from_tc_message(msg: &TcMessage) -> Self {
        Self {
            ifindex: msg.ifindex(),
            handle: msg.handle(),
            parent: msg.parent(),
            kind: msg.kind.clone(),
        }
    }

    /// Check if this is a netem qdisc
    pub fn is_netem(&self) -> bool {
        self.kind.as_deref() == Some("netem")
    }
}

/// Netlink event listener that monitors link and TC changes in real-time
pub struct NetlinkEventListener {
    /// Channel sender for netlink events
    event_tx: mpsc::Sender<NetlinkEvent>,
    /// Whether to subscribe to TC events
    subscribe_tc: bool,
}

impl NetlinkEventListener {
    /// Creates a new netlink event listener and returns the event receiver
    ///
    /// # Arguments
    ///
    /// * `buffer_size` - Size of the event channel buffer
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    #[allow(dead_code)]
    pub fn new(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (
            Self {
                event_tx,
                subscribe_tc: false,
            },
            event_rx,
        )
    }

    /// Creates a new netlink event listener with TC event subscription
    ///
    /// # Arguments
    ///
    /// * `buffer_size` - Size of the event channel buffer
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    pub fn new_with_tc(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (
            Self {
                event_tx,
                subscribe_tc: true,
            },
            event_rx,
        )
    }

    /// Starts listening for netlink events
    ///
    /// This spawns a background task that listens for link and optionally TC
    /// change events and sends them through the channel.
    ///
    /// # Returns
    ///
    /// Ok(()) if the listener started successfully, Err on failure
    pub async fn start(self) -> Result<(), String> {
        // Create an event stream that subscribes to link and optionally TC events
        let mut builder = EventStream::builder().links(true);

        if self.subscribe_tc {
            builder = builder.tc(true);
        }

        let mut stream = builder
            .build()
            .map_err(|e| format!("Failed to create event stream: {}", e))?;

        info!(
            "Netlink event listener started (links: true, tc: {})",
            self.subscribe_tc
        );

        // Spawn the message processing task
        let event_tx = self.event_tx;
        tokio::spawn(async move {
            loop {
                match stream.next().await {
                    Ok(Some(event)) => {
                        let netlink_events = parse_network_event(event);

                        for evt in netlink_events {
                            if event_tx.send(evt).await.is_err() {
                                warn!("Netlink event receiver dropped, stopping listener");
                                return;
                            }
                        }
                    }
                    Ok(None) => {
                        // Stream ended
                        warn!("Netlink event stream ended");
                        break;
                    }
                    Err(e) => {
                        error!("Error receiving netlink event: {}", e);
                        // Continue listening despite errors
                    }
                }
            }
            error!("Netlink message stream ended unexpectedly");
        });

        Ok(())
    }
}

/// Parse a NetworkEvent into one or more NetlinkEvents
fn parse_network_event(event: NetworkEvent) -> Vec<NetlinkEvent> {
    match event {
        NetworkEvent::NewLink(link_msg) => {
            let info = LinkInfo::from_link_message(&link_msg);
            debug!(
                "Netlink: NewLink event for {} (index {}), up: {:?}",
                info.name.as_deref().unwrap_or("unknown"),
                info.index,
                info.is_up
            );
            vec![NetlinkEvent::LinkAdded(info)]
        }
        NetworkEvent::DelLink(link_msg) => {
            let info = LinkInfo::from_link_message(&link_msg);
            debug!(
                "Netlink: DelLink event for {} (index {})",
                info.name.as_deref().unwrap_or("unknown"),
                info.index
            );
            vec![NetlinkEvent::LinkRemoved(info)]
        }
        NetworkEvent::NewQdisc(tc_msg) => {
            let info = TcInfo::from_tc_message(&tc_msg);
            debug!(
                "Netlink: NewQdisc event for ifindex {}, kind: {:?}, handle: {:08x}",
                info.ifindex, info.kind, info.handle
            );
            vec![NetlinkEvent::QdiscAdded(info)]
        }
        NetworkEvent::DelQdisc(tc_msg) => {
            let info = TcInfo::from_tc_message(&tc_msg);
            debug!(
                "Netlink: DelQdisc event for ifindex {}, kind: {:?}, handle: {:08x}",
                info.ifindex, info.kind, info.handle
            );
            vec![NetlinkEvent::QdiscRemoved(info)]
        }
        // Other events we don't care about
        _ => vec![],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_link_info_creation() {
        let info = LinkInfo {
            index: 1,
            name: Some("eth0".to_string()),
            is_up: Some(true),
        };
        assert_eq!(info.index, 1);
        assert_eq!(info.name, Some("eth0".to_string()));
        assert_eq!(info.is_up, Some(true));
    }

    #[test]
    fn test_tc_info_creation() {
        let info = TcInfo {
            ifindex: 2,
            handle: 0x10000,
            parent: 0xFFFFFFFF,
            kind: Some("netem".to_string()),
        };
        assert_eq!(info.ifindex, 2);
        assert!(info.is_netem());
    }

    #[test]
    fn test_tc_info_not_netem() {
        let info = TcInfo {
            ifindex: 2,
            handle: 0x10000,
            parent: 0xFFFFFFFF,
            kind: Some("fq_codel".to_string()),
        };
        assert!(!info.is_netem());
    }

    #[test]
    fn test_netlink_event_listener_creation() {
        let (listener, _rx) = NetlinkEventListener::new(100);
        assert!(!listener.subscribe_tc);
        drop(listener);
    }

    #[test]
    fn test_netlink_event_listener_with_tc() {
        let (listener, _rx) = NetlinkEventListener::new_with_tc(100);
        assert!(listener.subscribe_tc);
        drop(listener);
    }
}
