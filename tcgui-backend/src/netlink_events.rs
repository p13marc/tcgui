//! Netlink event listener for real-time interface change notifications.
//!
//! This module provides event-driven interface monitoring using nlink's
//! EventStream API. It listens for link events to detect interface additions,
//! removals, and state changes in real-time.

use nlink::netlink::events::{EventStream, NetworkEvent};
use tokio::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Events generated by the netlink listener
#[derive(Debug, Clone)]
#[allow(dead_code)] // Fields used for Debug logging and future event handling
pub enum NetlinkEvent {
    /// A new link was added
    Added(LinkInfo),
    /// A link was removed
    Removed(LinkInfo),
    /// A link state changed (up/down)
    StateChanged(LinkInfo),
}

/// Basic information about a link from netlink messages
#[derive(Debug, Clone)]
pub struct LinkInfo {
    /// Interface index
    pub index: u32,
    /// Interface name (if available)
    pub name: Option<String>,
}

impl LinkInfo {
    fn from_link_message(msg: &nlink::netlink::messages::LinkMessage) -> Self {
        Self {
            index: msg.ifindex() as u32,
            name: msg.name.clone(),
        }
    }
}

/// Netlink event listener that monitors link changes in real-time
pub struct NetlinkEventListener {
    /// Channel sender for netlink events
    event_tx: mpsc::Sender<NetlinkEvent>,
}

impl NetlinkEventListener {
    /// Creates a new netlink event listener and returns the event receiver
    ///
    /// # Returns
    ///
    /// A tuple of (NetlinkEventListener, mpsc::Receiver<NetlinkEvent>)
    pub fn new(buffer_size: usize) -> (Self, mpsc::Receiver<NetlinkEvent>) {
        let (event_tx, event_rx) = mpsc::channel(buffer_size);
        (Self { event_tx }, event_rx)
    }

    /// Starts listening for netlink events
    ///
    /// This spawns a background task that listens for link change events
    /// and sends them through the channel.
    ///
    /// # Returns
    ///
    /// Ok(()) if the listener started successfully, Err on failure
    pub async fn start(self) -> Result<(), String> {
        // Create an event stream that subscribes to link events
        let mut stream = EventStream::builder()
            .links(true)
            .build()
            .map_err(|e| format!("Failed to create event stream: {}", e))?;

        info!("Netlink event listener started using nlink EventStream");

        // Spawn the message processing task
        let event_tx = self.event_tx;
        tokio::spawn(async move {
            loop {
                match stream.next().await {
                    Ok(Some(event)) => {
                        let netlink_event = match event {
                            NetworkEvent::NewLink(link_msg) => {
                                let info = LinkInfo::from_link_message(&link_msg);
                                debug!(
                                    "Netlink: NewLink event for {} (index {})",
                                    info.name.as_deref().unwrap_or("unknown"),
                                    info.index
                                );
                                Some(NetlinkEvent::Added(info))
                            }
                            NetworkEvent::DelLink(link_msg) => {
                                let info = LinkInfo::from_link_message(&link_msg);
                                debug!(
                                    "Netlink: DelLink event for {} (index {})",
                                    info.name.as_deref().unwrap_or("unknown"),
                                    info.index
                                );
                                Some(NetlinkEvent::Removed(info))
                            }
                            // nlink doesn't have a separate SetLink event type,
                            // but NewLink events are also sent for state changes
                            _ => None,
                        };

                        if let Some(evt) = netlink_event
                            && event_tx.send(evt).await.is_err()
                        {
                            warn!("Netlink event receiver dropped, stopping listener");
                            break;
                        }
                    }
                    Ok(None) => {
                        // Stream ended
                        warn!("Netlink event stream ended");
                        break;
                    }
                    Err(e) => {
                        error!("Error receiving netlink event: {}", e);
                        // Continue listening despite errors
                    }
                }
            }
            error!("Netlink message stream ended unexpectedly");
        });

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_link_info_creation() {
        let info = LinkInfo {
            index: 1,
            name: Some("eth0".to_string()),
        };
        assert_eq!(info.index, 1);
        assert_eq!(info.name, Some("eth0".to_string()));
    }

    #[test]
    fn test_netlink_event_listener_creation() {
        let (listener, _rx) = NetlinkEventListener::new(100);
        // Just verify it can be created
        drop(listener);
    }
}
